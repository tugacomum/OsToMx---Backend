import { domainmodels } from "mendixmodelsdk";
import { MendixPlatformClient, setPlatformConfig } from "mendixplatformsdk";

interface AttributeData {
  Attribute: string;
  Keys?: string;
  Type: string;
  Mandatory: string;
  DefaultValue: string;
  Length?: string;
  Decimals?: string;
  IsAutoNumber?: boolean;
  IsIdentifier?: boolean;
  Description?: string;
}

interface IndexData {
  Name: string;
  Unique?: string;
  IsAutoGenerated?: boolean;
}

interface EntityData {
  Name: string;
  Label: string;
  Description: string;
  IsPublic: string;
  IsActive: string;
  IsMultitenant: string;
  IsClientEntity: string;
  Attributes: AttributeData[];
  Indexes: IndexData[];
}

const APP_ID = "15e89864-5ea4-4f36-ab1c-cebf70d4944b";

export async function executeScript(jsonData: EntityData[]) {
  await getApp(APP_ID);

  async function getApp(ai: string) {
    setPlatformConfig({
      mendixToken:
        "7c9iMCE3J28EBXXJmAmaAQeKEmyo4mAw9aU2PnPztTp7vDNvWxxsqdaKTZt1JJQPZmLCCqVV1S89YdrSsVgrndYoUGV8SbjguTSG",
    });
    const client = new MendixPlatformClient();
    const app = client.getApp(ai);

    const workingCopy = await app.createTemporaryWorkingCopy("main");

    const model = await workingCopy.openModel();
    const domainModelInterface = model
      .allDomainModels()
      .filter((dm) => dm.containerAsModule.name === "MyFirstModule")[0];

    const domainModel = await domainModelInterface.load();
    const entitiesMap: { [key: string]: domainmodels.Entity } = {};

    jsonData.forEach(entityData => {
      let entity = domainModel.entities.find(e => e.name === entityData.Name);

      if (!entity) {
          console.log(`Criando entidade "${entityData.Name}"`);
          entity = domainmodels.Entity.createIn(domainModel);
          entity.name = entityData.Name;
          entitiesMap[entityData.Name] = entity;

          entityData.Attributes.forEach((attributeData: AttributeData) => {
              if (attributeData.Attribute !== "Id") {
                  const attribute = domainmodels.Attribute.createIn(entity!);
                  attribute.name = attributeData.Attribute;
                  attribute.type = getDataType(attributeData.Type);

                  if (attribute.type instanceof domainmodels.StringAttributeType) {
                      attribute.type.length = attributeData.Length ? parseInt(attributeData.Length, 10) : 50;
                  } else if (attribute.type instanceof domainmodels.DecimalAttributeType) {
                      domainmodels.StoredValue.createIn(attribute).defaultValue = attributeData.Decimals ? attributeData.Decimals.toString() : "0";
                  }
              }
          });
      }
  });

  jsonData.forEach(entityData => {
      const entity = entitiesMap[entityData.Name];

      entityData.Attributes.forEach((attributeData: AttributeData) => {
          if (attributeData.IsIdentifier) {
              const referencedEntityName = attributeData.Type.replace(" Identifier", "");
              const referencedEntity = entitiesMap[referencedEntityName];

              if (referencedEntity) {
                  console.log(`Criando relação 1-1 entre ${entity.name} e ${referencedEntity.name}`);
                  const association1to1 = domainmodels.Association.createIn(domainModel);
                  association1to1.name = `${referencedEntity.name}_${entity.name}`;
                  association1to1.parent = entity;
                  association1to1.child = referencedEntity;
                  association1to1.type = domainmodels.AssociationType.Reference;
                  association1to1.owner = domainmodels.AssociationOwner.Both;
              } else {
                  console.log(`Entidade referenciada "${referencedEntityName}" não encontrada para o atributo "Id" em "${entity.name}"`);
              }
          }
      });
  });

    jsonData.forEach((entityData: any) => {
      const entity = domainModel.entities.find(
        (e) => e.name === entityData.Name
      );

      if (entity && entityData.Indexes) {
        entityData.Indexes.forEach((indexData: any) => {
          if (indexData.Name.toLowerCase() === "autoindex_id") {
            return;
          }

          const index = domainmodels.Index.createIn(entity);

          const attributeName = translateIndexName(indexData.Name);
          const attributeToIndex = entity.attributes.find(
            (attr) => translateIndexName(attr.name) === attributeName
          );

          if (attributeToIndex) {
            const indexedAttribute =
              domainmodels.IndexedAttribute.createIn(index);
            indexedAttribute.attribute = attributeToIndex;
          } else {
            console.log(
              `Atributo para índice ${indexData.Name} não encontrado em ${entityData.Name}.`
            );
          }
        });
      }
    });

    function getDataType(dataType: string) {
      switch (dataType.toLowerCase()) {
        case "text":
          return domainmodels.StringAttributeType.create(model);
        case "integer":
          return domainmodels.IntegerAttributeType.create(model);
        case "long integer":
          return domainmodels.LongAttributeType.create(model);
        case "boolean":
          return domainmodels.BooleanAttributeType.create(model);
        case "datetime":
          return domainmodels.DateTimeAttributeType.create(model);
        case "binary data":
          return domainmodels.BinaryAttributeType.create(model);
        case "enumeration":
          return domainmodels.EnumerationAttributeType.create(model);
        case "decimal":
          return domainmodels.DecimalAttributeType.create(model);
        default:
          return domainmodels.StringAttributeType.create(model);
      }
    }

    function translateIndexName(indexOrAttributeName: string): string {
      const lowerCasedName = indexOrAttributeName.toLowerCase();
      const translations: { [key: string]: string } = {
        title: "Titulo",
        name: "Nome",
      };

      return translations[lowerCasedName] || indexOrAttributeName;
    }

    await model.flushChanges();
    await workingCopy.commitToRepository("main");

    return workingCopy;
  }
}